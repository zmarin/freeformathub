---
import BaseLayout from '../../layouts/BaseLayout.astro';

const title = 'JSON Viewer';
const description = 'View formatted JSON in a distraction‑free full‑page viewer with copy and download controls.';
---

<BaseLayout title={title} description={description}>
  <div class="max-w-7xl mx-auto px-4 sm:px-6 lg:px-8 py-6">
    <div class="bg-white rounded-lg border border-gray-200 shadow-sm overflow-hidden">
      <div class="flex items-center justify-between px-4 py-3 border-b border-gray-200">
        <div class="flex items-center gap-3">
          <h1 class="text-lg font-semibold text-gray-900">JSON Viewer</h1>
          <span id="meta" class="text-xs text-gray-500"></span>
        </div>
        <div class="flex items-center gap-2">
          <div class="hidden sm:flex items-center border border-gray-200 rounded overflow-hidden">
            <button id="modeRaw" class="px-3 py-1 text-xs bg-gray-100  text-gray-700  border-r border-gray-200">Raw</button>
            <button id="modeTree" class="px-3 py-1 text-xs text-gray-700">Tree</button>
          </div>
          <input id="searchInput" placeholder="Search..." class="text-xs px-2 py-1 border rounded bg-white border-gray-300  text-gray-800" />
          <label class="hidden sm:inline-flex items-center gap-1 text-xs text-gray-600"><input id="filterToggle" type="checkbox" /> Filter</label>
          <div class="hidden sm:flex items-center gap-1 ml-2">
            <input id="jpInput" placeholder="$.path[*]" class="text-xs px-2 py-1 border rounded bg-white border-gray-300  text-gray-800" />
            <span id="jpCount" class="text-[11px] text-gray-500">0</span>
            <label class="inline-flex items-center gap-1 text-xs text-gray-600"><input id="jpFilterToggle" type="checkbox" /> Path filter</label>
            <button id="jpCollapseBtn" class="text-xs bg-gray-100  hover:bg-gray-200  px-2 py-1 rounded border text-gray-700">Collapse to matches</button>
          </div>
          <button id="copyBtn" class="text-xs bg-blue-600 hover:bg-blue-700 text-white px-3 py-1 rounded focus:outline-none focus:ring-2 focus:ring-blue-500">Copy</button>
          <button id="downloadBtn" class="text-xs bg-gray-100  hover:bg-gray-200  px-3 py-1 rounded border text-gray-700">Download</button>
          <button id="wrapBtn" class="text-xs bg-gray-100  hover:bg-gray-200  px-3 py-1 rounded border text-gray-700">Wrap: On</button>
          <button id="linesBtn" class="text-xs bg-gray-100  hover:bg-gray-200  px-3 py-1 rounded border text-gray-700">Lines: On</button>
          <div id="treeButtons" class="hidden sm:flex items-center gap-2">
            <button id="expandAllBtn" class="text-xs bg-gray-100  hover:bg-gray-200  px-3 py-1 rounded border text-gray-700">Expand all</button>
            <button id="collapseAllBtn" class="text-xs bg-gray-100  hover:bg-gray-200  px-3 py-1 rounded border text-gray-700">Collapse all</button>
          </div>
        </div>
      </div>

      <div class="relative" id="rawPane">
        <div id="lines" class="absolute left-0 top-0 bottom-0 w-12 bg-gray-50 border-r border-gray-200 overflow-hidden"></div>
        <pre id="content" class="pl-16 p-4 text-sm font-mono text-gray-900  whitespace-pre-wrap break-words overflow-auto" style="min-height: 60vh"></pre>
      </div>

      <div id="treePane" class="hidden">
        <div id="tree" class="p-3 max-h-[70vh] overflow-auto text-sm font-mono"></div>
      </div>
    </div>
  </div>

  <script type="module">
    import { runJsonPath } from '../../tools/development/json-path-extractor';
    const qs = new URLSearchParams(window.location.search);
    const id = qs.get('id');
    let text = '';
    if (id) {
      try { text = sessionStorage.getItem(`ffh.json.${id}`) || ''; } catch {}
    }
    const contentEl = document.getElementById('content');
    const linesEl = document.getElementById('lines');
    const metaEl = document.getElementById('meta');
    const copyBtn = document.getElementById('copyBtn');
    const downloadBtn = document.getElementById('downloadBtn');
    const wrapBtn = document.getElementById('wrapBtn');
    const linesBtn = document.getElementById('linesBtn');
    const modeRawBtn = document.getElementById('modeRaw');
    const modeTreeBtn = document.getElementById('modeTree');
    const searchInput = document.getElementById('searchInput');
    const filterToggle = document.getElementById('filterToggle');
    const treeButtons = document.getElementById('treeButtons');
    const expandAllBtn = document.getElementById('expandAllBtn');
    const collapseAllBtn = document.getElementById('collapseAllBtn');
    const rawPane = document.getElementById('rawPane');
    const treePane = document.getElementById('treePane');
    const treeRoot = document.getElementById('tree');
    const jpInput = document.getElementById('jpInput');
    const jpCount = document.getElementById('jpCount');
    const jpFilterToggle = document.getElementById('jpFilterToggle');
    const jpCollapseBtn = document.getElementById('jpCollapseBtn');

    let wrap = true;
    let showLines = true;
    let mode = 'raw'; // 'raw' | 'tree'
    let parsed;
    try { parsed = JSON.parse(text); } catch { parsed = undefined; }
    let matchedPaths = new Set();
    let keepAncestors = new Set();

    function updateJsonPathMatches(){
      matchedPaths = new Set();
      keepAncestors = new Set();
      const expr = (jpInput?.value || '').trim();
      if (!expr || !parsed) { if (jpCount) jpCount.textContent = '0'; return; }
      try {
        const results = runJsonPath(parsed, expr);
        for (const r of results) {
          matchedPaths.add(r.path);
          // build ancestor chain
          let cur = r.path;
          while (cur && cur !== '$'){
            keepAncestors.add(cur);
            if (cur.endsWith(']')){
              const i = cur.lastIndexOf('[');
              cur = i > -1 ? cur.slice(0, i) : '$';
            } else {
              const j = cur.lastIndexOf('.');
              cur = j > -1 ? cur.slice(0, j) : '$';
            }
          }
          keepAncestors.add('$');
        }
        if (jpCount) jpCount.textContent = String(matchedPaths.size);
      } catch (e){
        if (jpCount) jpCount.textContent = '0';
      }
    }

    function escapeHtml(s){
      return s.replace(/[&<>"']/g, c => ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[c]));
    }

    function renderRaw(txt) {
      const q = (searchInput.value || '').trim();
      if (!q) {
        contentEl.textContent = txt || 'No content';
      } else {
        const escaped = escapeHtml(txt || '');
        const re = new RegExp(q.replace(/[.*+?^${}()|[\]\\]/g, '\\$&'), 'gi');
        contentEl.innerHTML = escaped.replace(re, m => `<mark class="bg-yellow-200 text-black">${m}</mark>`);
      }
      updateLines();
      metaEl.textContent = txt ? `${txt.length} chars • ${txt.split('\n').length} lines` : '';
    }

    function updateLines() {
      if (!showLines) { linesEl.style.display = 'none'; contentEl.classList.remove('pl-16'); return; }
      linesEl.style.display = 'block';
      contentEl.classList.add('pl-16');
      const n = (contentEl.textContent || '').split('\n').length;
      const frag = document.createDocumentFragment();
      linesEl.innerHTML = '';
      for (let i = 1; i <= n; i++) {
        const d = document.createElement('div');
        d.className = 'px-2 py-0.5 text-xs text-gray-500 text-right leading-normal select-none';
        d.textContent = String(i);
        frag.appendChild(d);
      }
      linesEl.appendChild(frag);
    }

    wrapBtn.addEventListener('click', () => {
      wrap = !wrap;
      if (wrap) {
        contentEl.classList.remove('whitespace-pre');
        contentEl.classList.add('whitespace-pre-wrap', 'break-words');
        wrapBtn.textContent = 'Wrap: On';
      } else {
        contentEl.classList.remove('whitespace-pre-wrap', 'break-words');
        contentEl.classList.add('whitespace-pre');
        wrapBtn.textContent = 'Wrap: Off';
      }
      updateLines();
    });

    linesBtn.addEventListener('click', () => {
      showLines = !showLines;
      linesBtn.textContent = showLines ? 'Lines: On' : 'Lines: Off';
      updateLines();
    });

    copyBtn.addEventListener('click', async () => {
      try { await navigator.clipboard.writeText(contentEl.textContent || ''); copyBtn.textContent = 'Copied!'; setTimeout(() => copyBtn.textContent = 'Copy', 1200); } catch {}
    });

    downloadBtn.addEventListener('click', () => {
      const blob = new Blob([contentEl.textContent || ''], { type: 'application/json' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url; a.download = 'formatted.json'; a.click();
      URL.revokeObjectURL(url);
    });

    // Tree view
    let collapsed = new Set();
    function shouldShowNode(key, value){
      const q = (searchInput.value || '').trim();
      if (!q) return true;
      const s = String(key ?? '') + ' ' + (value === null || typeof value === 'object' ? '' : String(value));
      return s.toLowerCase().includes(q.toLowerCase());
    }

    function renderTree(){
      treeRoot.innerHTML = '';
      const q = (searchInput.value || '').trim();
      const filter = !!filterToggle.checked && q;
      const pathFilter = !!jpFilterToggle.checked && matchedPaths.size > 0;
      const keepSet = new Set(keepAncestors);
      for (const p of matchedPaths) keepSet.add(p);
      function node(path, key, value, level){
        const isObj = value && typeof value === 'object' && !Array.isArray(value);
        const isArr = Array.isArray(value);
        const isPrim = !isObj && !isArr;
        const show = shouldShowNode(key, value);
        if ((filter && !show && (isObj || isArr)) || (pathFilter && !keepSet.has(path) && (isObj || isArr))){
          // if filtering, check any descendant matches
          let matched = false;
          const check = (v)=>{
            if (matched) return; 
            if (v && typeof v === 'object'){
              for (const k in v){ if (shouldShowNode(k, v[k])) { matched = true; break; } check(v[k]); }
            }
          };
          check(value);
          if (!matched && !pathFilter) return; // hide subtree by search
          if (pathFilter && !keepSet.has(path)) return;
        }
        const row = document.createElement('div');
        row.style.paddingLeft = `${level*16}px`;
        const isMatch = matchedPaths.has(path);
        row.className = `py-0.5 ${isMatch ? 'bg-yellow-50 ' : (show && q ? 'bg-yellow-50 ' : '')}`;
        const toggle = document.createElement('button');
        toggle.className = 'mr-1 text-xs w-5 inline-flex items-center justify-center rounded border border-gray-300  text-gray-600';
        toggle.textContent = collapsed.has(path) ? '+' : '-';
        toggle.addEventListener('click', ()=>{ if (collapsed.has(path)) collapsed.delete(path); else collapsed.add(path); renderTree(); });
        const keySpan = document.createElement('span');
        keySpan.className = isPrim ? 'text-gray-500' : 'text-blue-700 ';
        keySpan.textContent = key !== undefined ? String(key) : '$';
        const valueSpan = document.createElement('span');
        if (isPrim){
          valueSpan.innerHTML = `: <span class="${typeof value==='string'?'text-green-700 ': typeof value==='number'?'text-orange-600': 'text-indigo-600'}">${escapeHtml(JSON.stringify(value))}</span>`;
        }else{
          const size = isArr ? value.length : Object.keys(value).length;
          valueSpan.innerHTML = ` <span class="text-gray-500">${isArr?`[${size}]`:`{${size}}`}</span>`;
        }
        if (!isPrim) row.appendChild(toggle);
        row.appendChild(keySpan);
        row.appendChild(valueSpan);
        treeRoot.appendChild(row);
        if (isPrim || collapsed.has(path)) return;
        if (isArr){
          for (let i=0;i<value.length;i++) node(`${path}[${i}]`, i, value[i], level+1);
        } else if (isObj){
          for (const k of Object.keys(value)) node(`${path}.${k}`, k, value[k], level+1);
        }
      }
      node('$', undefined, parsed, 0);
    }

    // Mode switching
    function setModeRaw(){ mode='raw'; rawPane.classList.remove('hidden'); treePane.classList.add('hidden'); treeButtons.classList.add('hidden'); modeRawBtn.classList.add('bg-gray-100',''); modeTreeBtn.classList.remove('bg-gray-100',''); renderRaw(text); }
    function setModeTree(){ if(!parsed){ try{parsed=JSON.parse(text);}catch{}} mode='tree'; rawPane.classList.add('hidden'); treePane.classList.remove('hidden'); treeButtons.classList.remove('hidden'); modeTreeBtn.classList.add('bg-gray-100',''); modeRawBtn.classList.remove('bg-gray-100',''); renderTree(); }

    modeRawBtn.addEventListener('click', setModeRaw);
    modeTreeBtn.addEventListener('click', setModeTree);
    expandAllBtn.addEventListener('click', ()=>{ collapsed = new Set(); renderTree(); });
    collapseAllBtn.addEventListener('click', ()=>{
      collapsed = new Set();
      // pre-collapse every path (collect)
      const collect = (v, p)=>{ if(v && typeof v==='object'){ collapsed.add(p); if(Array.isArray(v)){ for(let i=0;i<v.length;i++) collect(v[i], `${p}[${i}]`);} else { for(const k in v) collect(v[k], `${p}.${k}`);} } };
      collect(parsed,'$');
      renderTree();
    });

    // JSONPath controls
    jpInput.addEventListener('input', ()=>{ updateJsonPathMatches(); if(mode==='tree') renderTree(); });
    jpFilterToggle.addEventListener('change', ()=>{ if(mode==='tree') renderTree(); });
    jpCollapseBtn.addEventListener('click', ()=>{
      if (matchedPaths.size === 0) return;
      // collapse all except ancestors of matches
      collapsed = new Set();
      const collect = (v, p)=>{ if(v && typeof v==='object'){ collapsed.add(p); if(Array.isArray(v)){ for(let i=0;i<v.length;i++) collect(v[i], `${p}[${i}]`);} else { for(const k in v) collect(v[k], `${p}.${k}`);} } };
      collect(parsed,'$');
      for (const p of keepAncestors) collapsed.delete(p);
      for (const p of matchedPaths) collapsed.delete(p);
      renderTree();
    });

    // Search
    searchInput.addEventListener('input', ()=>{ mode==='raw'? renderRaw(text): renderTree(); });
    filterToggle.addEventListener('change', ()=>{ if(mode==='tree') renderTree(); else renderRaw(text); });

    // Initial render
    updateJsonPathMatches();
    renderRaw(text);
  </script>
</BaseLayout>
